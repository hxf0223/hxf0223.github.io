<!DOCTYPE html> <html lang="zh-CN"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> STL 图解 | Roderick Huang </title> <meta name="author" content="Roderick Huang"> <meta name="description" content="Roderick Huang 的个人博客，记录工作与技术。 "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="manifest" href="/manifest.json"> <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"> <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1a1a2e"> <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
      navigator.serviceWorker.register('/sw.js');
    });
  }
</script> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:; worker-src 'self';"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?v=6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hxf0223.github.io/blog/2024/STL%E5%9B%BE%E8%A7%A3/"> <script src="/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Roderick</span> Huang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">STL 图解</h1> <p class="post-meta"> Created on October 10, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> Cpp</a>   ·   <a href="/blog/category/cpp"> <i class="fa-solid fa-tag fa-sm"></i> Cpp</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><code class="language-plaintext highlighter-rouge">STL</code> 包含五种主要组件：</p> <ul> <li>算法（algorithm）：定义计算过程。</li> <li>容器（container）：管理一组内存位置。</li> <li>迭代器（iterator）：提供算法遍历容器的方法。</li> <li>函数对象（function object）：将函数封装在对象中，供其他组件使用。</li> <li>适配器（adaptor）：调整组件以提供不同的接口。</li> </ul> <p>从实现来看还需要包含：</p> <ul> <li>分配器（allocator）：用于处理容器对内存的分配与释放请求。</li> </ul> <p>以下分析适用于 <code class="language-plaintext highlighter-rouge">GCC9</code> 。</p> <h2 id="1-源码阅读">1. 源码阅读</h2> <h3 id="11-template">1.1. ::template</h3> <p>在 <code class="language-plaintext highlighter-rouge">__rebind</code> 函数体中，在 <code class="language-plaintext highlighter-rouge">::</code> 后面有个 <code class="language-plaintext highlighter-rouge">template</code> 关键字，这是用于告诉编译器 <code class="language-plaintext highlighter-rouge">template</code> 后面的 <code class="language-plaintext highlighter-rouge">&lt;</code> 不是比较符号，而是模板参数符号。就是类似于 <code class="language-plaintext highlighter-rouge">_Tp</code> 前面的 <code class="language-plaintext highlighter-rouge">typename</code> 是告诉编译器 <code class="language-plaintext highlighter-rouge">::</code> 后面的是类成员函数，而不是 <code class="language-plaintext highlighter-rouge">static</code> 函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">_Tp</span><span class="o">::</span><span class="k">template</span> <span class="n">rebind</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">&gt;</span><span class="o">::</span><span class="n">other</span><span class="p">;</span>
</code></pre></div></div> <h2 id="2-allocator">2. allocator<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> </h2> <p>分配器是负责封装堆内存管理的对象。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/allocator.drawio.svg" alt="allocator"></p> <h3 id="21-分配器">2.1. 分配器</h3> <p>上图左侧。</p> <p>C++的默认的内存分配器 <code class="language-plaintext highlighter-rouge">std::allocator</code>，继承至 <code class="language-plaintext highlighter-rouge">__gnu_cxx::new_allocator</code>。</p> <h4 id="211-__gnu_cxxnew_allocator">2.1.1. __gnu_cxx::new_allocator</h4> <p>（1）对传入类型进行了类型萃取。</p> <p>（2）<code class="language-plaintext highlighter-rouge">rebind</code> 重新绑定，定义 <code class="language-plaintext highlighter-rouge">other</code> 类型，用于萃取器萃取类型。</p> <p>（3）封装实现分配对象内存、初始化对象、析构对象、释放对象内存，底层使用 <code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code>。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">address()</code> : 用于获取分配地址</li> <li> <code class="language-plaintext highlighter-rouge">allocate()</code> : 用于分配内存</li> <li> <code class="language-plaintext highlighter-rouge">deallocate()</code> : 用于释放内存</li> <li> <code class="language-plaintext highlighter-rouge">max_size()</code> : 获取最大可分配数量</li> <li> <code class="language-plaintext highlighter-rouge">construct()</code> : 调用已分配内存对象的构造函数</li> <li> <code class="language-plaintext highlighter-rouge">destroy()</code> : 调用析构函数</li> </ul> <h4 id="212-stdallocator">2.1.2. std::allocator</h4> <p>（1）偏特化处理 <code class="language-plaintext highlighter-rouge">void</code></p> <p>（2）偏特化处理 <code class="language-plaintext highlighter-rouge">const</code> 和 <code class="language-plaintext highlighter-rouge">volatile</code>，重新形成有效的分配器类型</p> <p>（3）类模板 <code class="language-plaintext highlighter-rouge">std::allocator</code></p> <ul> <li> <code class="language-plaintext highlighter-rouge">rebind</code> 重新绑定，定义 <code class="language-plaintext highlighter-rouge">other</code> 类型，用于萃取器获取类型。</li> </ul> <h3 id="22-萃取器">2.2. 萃取器</h3> <p>上图右侧。</p> <p>类 <code class="language-plaintext highlighter-rouge">__gnu_cxx::__alloc_traits</code> 继承于类<code class="language-plaintext highlighter-rouge">std::allocator_traits</code>，再继承于 <code class="language-plaintext highlighter-rouge">std::__allocator_traits_base</code>，用于获取内存分配器 <code class="language-plaintext highlighter-rouge">allocator</code> 的各个属性。</p> <h4 id="221-std__allocator_traits_base">2.2.1. std::__allocator_traits_base</h4> <ul> <li>用于获取内存分配器 <code class="language-plaintext highlighter-rouge">allocator</code> 的各个属性。</li> </ul> <h4 id="222-stdallocator_traits">2.2.2. std::allocator_traits</h4> <ul> <li>私有函数模板 <code class="language-plaintext highlighter-rouge">_S</code> 开头是封装对应名称分配器 <code class="language-plaintext highlighter-rouge">_Alloc</code> 原生的函数模板</li> <li>共有函数模板是封装自身对应名称 <code class="language-plaintext highlighter-rouge">_S</code> 开头的私有函数模板</li> <li>有个特化版本是当 <code class="language-plaintext highlighter-rouge">_Alloc</code> 是 <code class="language-plaintext highlighter-rouge">std::allocator</code>，起别名后重复调用通用模板的共有函数模板</li> </ul> <h4 id="223-__gnu_cxx__alloc_traits">2.2.3. <code class="language-plaintext highlighter-rouge">__gnu_cxx::__alloc_traits</code> </h4> <ul> <li>全部继承 <code class="language-plaintext highlighter-rouge">std::allocator_traits</code>，重载 <code class="language-plaintext highlighter-rouge">construct</code> 和 <code class="language-plaintext highlighter-rouge">destroy</code> 非标准类型指针</li> <li> <code class="language-plaintext highlighter-rouge">_S</code> 开头的静态函数是封装父类萃取类型</li> </ul> <h2 id="3-iterator">3. iterator<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> </h2> <p>迭代器是指向容器内元素的对象（如指针）。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/iterator.drawio.svg" alt="iterator"></p> <h3 id="31-迭代器类型">3.1. 迭代器类型</h3> <p>上图中间。</p> <h4 id="311-stditerator_tag">3.1.1. std::iterator_tag</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///  Marking input iterators.</span>
<span class="k">struct</span> <span class="nc">input_iterator_tag</span> <span class="p">{};</span>

<span class="c1">///  Marking output iterators.</span>
<span class="k">struct</span> <span class="nc">output_iterator_tag</span> <span class="p">{};</span>

<span class="c1">/// Forward iterators support a superset of input iterator operations.</span>
<span class="k">struct</span> <span class="nc">forward_iterator_tag</span> <span class="o">:</span> <span class="k">public</span> <span class="n">input_iterator_tag</span> <span class="p">{};</span>

<span class="c1">/// Bidirectional iterators support a superset of forward iterator</span>
<span class="c1">/// operations.</span>
<span class="k">struct</span> <span class="nc">bidirectional_iterator_tag</span> <span class="o">:</span> <span class="k">public</span> <span class="n">forward_iterator_tag</span> <span class="p">{};</span>

<span class="c1">/// Random-access iterators support a superset of bidirectional</span>
<span class="c1">/// iterator operations.</span>
<span class="k">struct</span> <span class="nc">random_access_iterator_tag</span> <span class="o">:</span> <span class="k">public</span> <span class="n">bidirectional_iterator_tag</span> <span class="p">{};</span>
</code></pre></div></div> <p>STL库支持的迭代器类型是所有编程语言中最全面的，共有五种：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">InputIterator</code> : 输入迭代器。支持对容器元素的逐个遍历，以及对元素的读取 (input)；</li> <li> <code class="language-plaintext highlighter-rouge">OutputIterator</code> : 输出迭代器。支持对容器元素的逐个遍历，以及对元素的写入 (output)。</li> <li> <code class="language-plaintext highlighter-rouge">ForwardIterator</code> : 前向迭代器。向前逐个遍历元素。可以对元素读取；</li> <li> <code class="language-plaintext highlighter-rouge">BidirectionalIterator</code> : 双向迭代器。支持向前向后逐个遍历元素，可以对元素读取。</li> <li> <code class="language-plaintext highlighter-rouge">RandomAccessIterator</code> : 随机访问迭代器。支持O(1)时间复杂度对元素的随机位置访问，支持对元素的读取。</li> </ol> <p>这些是空类型用于区分不同的迭代器，区别不在于它们所包含的内容，而在于它们的是什么类型，然后可以基于不同迭代器类型支持的不同操作。</p> <h4 id="312-stditerator">3.1.2. std::iterator</h4> <p>此类只定义嵌套的 <code class="language-plaintext highlighter-rouge">typedef</code>，子类迭代器类可以继承这个类以节省一些工作，然后用于特化和重载。</p> <h4 id="313-stditerator_traits">3.1.3. std::iterator_traits</h4> <p>此类只定义嵌套的 <code class="language-plaintext highlighter-rouge">typedef</code>，简单地从 <code class="language-plaintext highlighter-rouge">Iterator</code> 转发嵌套的 <code class="language-plaintext highlighter-rouge">typedef</code> 参数。 提供指针和指向常量的指针的特化版本。</p> <h3 id="32-迭代器函数">3.2. 迭代器函数</h3> <p>上图左侧。</p> <h4 id="321-stddistance">3.2.1. std::distance</h4> <p>计算迭代器之间的距离，通过一层类型判断确定 <code class="language-plaintext highlighter-rouge">iterator_tag</code>，然后转发给具体函数 <code class="language-plaintext highlighter-rouge">__distance()</code>。包括单向、随机。</p> <h4 id="322-stdadvance">3.2.2. std::advance</h4> <p>向前或向后移动迭代器，通过一层类型判断确定 <code class="language-plaintext highlighter-rouge">iterator_tag</code>，然后转发给具体函数 <code class="language-plaintext highlighter-rouge">__advance()</code>。包括单向、双向、随机。</p> <blockquote> <p>next() 向后移动</p> <p>prev() 向前移动</p> </blockquote> <h3 id="33-衍生迭代器">3.3. 衍生迭代器</h3> <p>上图右侧。</p> <h4 id="331-stdreverse_iterator">3.3.1. std::reverse_iterator</h4> <p>反向迭代器。</p> <ul> <li>记录当前迭代器</li> <li>重载操作运算符，<code class="language-plaintext highlighter-rouge">++</code> 内部实现为 <code class="language-plaintext highlighter-rouge">--</code>，<code class="language-plaintext highlighter-rouge">--</code> 内部实现为 <code class="language-plaintext highlighter-rouge">++</code> 等反向操作</li> <li>该迭代器全局的各种重载操作运算符函数模板</li> </ul> <h4 id="332-stdback_insert_iterator">3.3.2. std::back_insert_iterator</h4> <p>尾部插入迭代器。</p> <ul> <li>记录一个容器，调用容器自己实现的 <code class="language-plaintext highlighter-rouge">push_back()</code> </li> <li>重载操作运算符，返回自身解引用</li> <li>该迭代器全局的插入函数模板</li> </ul> <h4 id="333-stdfront_insert_iterator">3.3.3. std::front_insert_iterator</h4> <p>头部插入迭代器。</p> <ul> <li>记录一个容器，调用容器自己实现的 <code class="language-plaintext highlighter-rouge">push_front()</code> </li> <li>重载操作运算符，返回自身解引用</li> <li>该迭代器全局的插入函数模板</li> </ul> <h4 id="334-stdinsert_iterator">3.3.4. std::insert_iterator</h4> <p>插入迭代器。</p> <ul> <li>记录一个容器，调用容器自己实现的 <code class="language-plaintext highlighter-rouge">insert()</code> </li> <li>重载操作运算符，返回自身解引用</li> <li>该迭代器全局的插入函数模板</li> </ul> <h4 id="335-__gnu_cxx__normal_iterator">3.3.5. <code class="language-plaintext highlighter-rouge">__gnu_cxx::__normal_iterator</code> </h4> <p>这个迭代器适配器是一个普通的适配器，因为它不会改变迭代器参数的任何运算符的语义。它的主要目的是将不是类的迭代器（例如指针）转换为类迭代器。<code class="language-plaintext highlighter-rouge">_Container </code>参数单独存在（不同容器），因此使用此模板的不同容器可以实例化不同的类型，即使 <code class="language-plaintext highlighter-rouge">_Iterator</code> 参数相同。</p> <ul> <li>记录当前迭代器</li> <li>重载操作运算符</li> <li>该迭代器全局的各种重载操作运算符函数模板</li> </ul> <h4 id="336-stdmove_iterator">3.3.6. std::move_iterator</h4> <p>类模板 <code class="language-plaintext highlighter-rouge">move_iterator</code> 是一个迭代器适配器，其行为与基础迭代器相同，只是其解引用运算符隐式将基础迭代的解引用运算符返回的值转换为右值引用。可以使用移动迭代器调用一些通用算法，以移动代替复制。</p> <ul> <li>记录当前迭代器</li> <li>重载操作运算符</li> <li>该迭代器全局的各种重载操作运算符函数模板</li> </ul> <h2 id="4-vector">4. vector</h2> <p><code class="language-plaintext highlighter-rouge">std::vector</code> 是封装动态数组的顺序容器。连续存储元素，这意味着不仅可通过迭代器，还能用指向元素的常规指针访问元素。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/vector.drawio.svg" alt="vector"></p> <h3 id="41-基类">4.1. 基类</h3> <p><code class="language-plaintext highlighter-rouge">std::_Vector_base</code> 是基类，通过萃取获取分配类型和分配类型指针。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">typename</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__alloc_traits</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">rebind</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">&gt;</span><span class="o">::</span><span class="n">other</span> <span class="n">_Tp_alloc_type</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">typename</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__alloc_traits</span><span class="o">&lt;</span><span class="n">_Tp_alloc_type</span><span class="o">&gt;::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span>
</code></pre></div></div> <p>具体保存数据结构。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">_Vector_impl_data</span> <span class="p">{</span>
  <span class="n">pointer</span> <span class="n">_M_start</span><span class="p">;</span>           <span class="c1">// 起始指针</span>
  <span class="n">pointer</span> <span class="n">_M_finish</span><span class="p">;</span>          <span class="c1">// 实际空间结束指针</span>
  <span class="n">pointer</span> <span class="n">_M_end_of_storage</span><span class="p">;</span>  <span class="c1">// 分配空间结束指针</span>
<span class="p">}</span>
</code></pre></div></div> <p>真正数据结构是 <code class="language-plaintext highlighter-rouge">_Vector_impl</code>，该结构多重继承于 <code class="language-plaintext highlighter-rouge">_Vector_impl_data</code> 和 <code class="language-plaintext highlighter-rouge">_Tp_alloc_type</code>（具体类型）实现封装管理内存调整（增加、收缩、删除）。</p> <h3 id="42-具体类">4.2. 具体类</h3> <p><code class="language-plaintext highlighter-rouge">std::vector</code> 实现具体成员函数，实际都是对以下指针进行操作，部分进行迭代器封装。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span>
<span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span>
<span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_end_of_storage</span>
</code></pre></div></div> <p>例如 <code class="language-plaintext highlighter-rouge">begin()</code> <code class="language-plaintext highlighter-rouge">end()</code> <code class="language-plaintext highlighter-rouge">empty()</code> 函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  *  Returns a read/write iterator that points to the first
  *  element in the %vector.  Iteration is done in ordinary
  *  element order.
  */</span>
<span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="n">_GLIBCXX_NOEXCEPT</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
  *  Returns a read/write iterator that points one past the last
  *  element in the %vector.  Iteration is done in ordinary
  *  element order.
  */</span>
<span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="n">_GLIBCXX_NOEXCEPT</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
  *  Returns true if the %vector is empty.  (Thus begin() would
  *  equal end().)
  */</span>
<span class="n">_GLIBCXX_NODISCARD</span> <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">==</span> <span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="5-list">5. list</h2> <p><code class="language-plaintext highlighter-rouge">std::list</code> 是支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/list.drawio.svg" alt="list"></p> <h3 id="51-节点类型">5.1. 节点类型</h3> <p>节点类型分为以下三个：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">_List_node_base</code> : 基类节点，包含前向、后向指针。</li> <li> <code class="language-plaintext highlighter-rouge">_List_node_header</code> : 头节点，继承于 <code class="language-plaintext highlighter-rouge">_List_node_base</code>，额外包含节点个数。</li> <li> <code class="language-plaintext highlighter-rouge">_List_node</code> : 数据节点，继承于 <code class="language-plaintext highlighter-rouge">_List_node_base</code>，额外包含数据。</li> </ul> <h3 id="52-基类">5.2. 基类</h3> <p><code class="language-plaintext highlighter-rouge">std::_List_node</code> 是基类，该类的真正结构是 <code class="language-plaintext highlighter-rouge">_List_impl</code>，继承于 <code class="language-plaintext highlighter-rouge">_List_node&lt;_Tp&gt;</code>，内部包含 <code class="language-plaintext highlighter-rouge">_List_node_header</code> 头节点。<code class="language-plaintext highlighter-rouge">std::_List_node</code> 中声明 <code class="language-plaintext highlighter-rouge">_List_impl</code> 成员变量，操作都是对 <code class="language-plaintext highlighter-rouge">_List_impl</code> 成员变量中数据操作。</p> <h3 id="53-具体类">5.3. 具体类</h3> <p>std::list 实现具体成员函数，实际都是对以下指针进行操作，部分进行迭代器封装。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span>
</code></pre></div></div> <p>例如 <code class="language-plaintext highlighter-rouge">begin()</code> <code class="language-plaintext highlighter-rouge">end()</code> <code class="language-plaintext highlighter-rouge">empty()</code> 函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="cm">/**
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       */</span>
      <span class="n">iterator</span>
      <span class="nf">begin</span><span class="p">()</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
      <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">.</span><span class="n">_M_next</span><span class="p">);</span> <span class="p">}</span>

      <span class="cm">/**
       *  Returns a read/write iterator that points one past the last
       *  element in the %list.  Iteration is done in ordinary element
       *  order.
       */</span>
      <span class="n">iterator</span>
      <span class="nf">end</span><span class="p">()</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
      <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">);</span> <span class="p">}</span>

      <span class="cm">/**
       *  Returns true if the %list is empty.  (Thus begin() would equal
       *  end().)
       */</span>
      <span class="n">_GLIBCXX_NODISCARD</span> <span class="kt">bool</span>
      <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
      <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">.</span><span class="n">_M_next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h2 id="6-deque">6. deque</h2> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/deque.png" alt="deque"></p> <p><code class="language-plaintext highlighter-rouge">std::deque</code>（double-ended queue，双端队列）是有下标顺序容器，它允许在它的首尾两端快速插入及删除。另外，在 <code class="language-plaintext highlighter-rouge">deque</code> 任一端插入或删除不会使指向其余元素的指针或引用失效。</p> <p><code class="language-plaintext highlighter-rouge">deque</code> 的元素不是相接存储的：典型实现用单独分配的固定尺寸数组的序列，外加额外的序列，这表示下标访问必须进行二次指针解引用，与之相比 <code class="language-plaintext highlighter-rouge">vector</code> 的下标访问只进行一次。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/deque.drawio.svg" alt="deque2"></p> <h3 id="61-基类">6.1. 基类</h3> <p><code class="language-plaintext highlighter-rouge">std::_Deque_base</code> 是基类，通过萃取获取分配类型和分配类型指针。</p> <p>真正数据结构是 <code class="language-plaintext highlighter-rouge">_Deque_impl</code>，该结构继承于 <code class="language-plaintext highlighter-rouge">_Tp_alloc_type</code>（具体类型）实现封装管理内存调整（初始化、增加、删除）。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">_Deque_impl</span>
<span class="p">{</span>
  <span class="n">_Map_pointer</span> <span class="n">_M_map</span><span class="p">;</span>       <span class="c1">// 固定尺寸数组关联的序列</span>
  <span class="kt">size_t</span>       <span class="n">_M_map_size</span><span class="p">;</span>  <span class="c1">// 序列大小</span>
  <span class="n">iterator</span>     <span class="n">_M_start</span><span class="p">;</span>     <span class="c1">// 起始迭代器</span>
   <span class="n">iterator</span>     <span class="n">_M_finish</span><span class="p">;</span>   <span class="c1">// 终止迭代器</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="62-具体类">6.2. 具体类</h3> <p><code class="language-plaintext highlighter-rouge">std::deque</code> 实现具体成员函数，实际都是对以下指针进行操作，部分进行迭代器封装。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span>
<span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span>
</code></pre></div></div> <p>例如 <code class="language-plaintext highlighter-rouge">push_front()</code> <code class="language-plaintext highlighter-rouge">push_back()</code>函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="cm">/**
       *  @brief  Add data to the front of the %deque.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the front of the %deque and assigns the given
       *  data to it.  Due to the nature of a %deque this operation
       *  can be done in constant time.
       */</span>
      <span class="kt">void</span>
      <span class="nf">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span>
      <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_first</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">,</span>
                        <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">__x</span><span class="p">);</span>
            <span class="o">--</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span>
       <span class="p">}</span> <span class="k">else</span>
            <span class="nf">_M_push_front_aux</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/**
       *  @brief  Add data to the end of the %deque.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %deque and assigns the given data
       *  to it.  Due to the nature of a %deque this operation can be
       *  done in constant time.
       */</span>
      <span class="kt">void</span>
      <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span>
      <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span>
	    <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">{</span>
	    <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">,</span>
				     <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
	    <span class="o">++</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span>
	  <span class="p">}</span>
	<span class="k">else</span>
	  <span class="nf">_M_push_back_aux</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></div></div> <h2 id="7-适配器">7. 适配器</h2> <h3 id="71-stack">7.1. stack</h3> <p><code class="language-plaintext highlighter-rouge">std::stack</code> 类是容器适配器，它给予程序员栈的功能——特别是 <code class="language-plaintext highlighter-rouge">FILO</code>（先进后出）数据结构。</p> <p>适配器可以为标准容器 <code class="language-plaintext highlighter-rouge">std::vector</code>（包括 <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;</code>）、<code class="language-plaintext highlighter-rouge">std::deque</code> 和 <code class="language-plaintext highlighter-rouge">std::list</code>。如果没有为特定的 <code class="language-plaintext highlighter-rouge">stack</code> 类特化指定容器类，那么就会使用标准容器 <code class="language-plaintext highlighter-rouge">std::deque</code>。</p> <p>实现方式一般是声明适配器变量，然后封装调用适配器容器函数来实现自己函数功能。例如 <code class="language-plaintext highlighter-rouge">top()</code> <code class="language-plaintext highlighter-rouge">push()</code>函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Sequence</span> <span class="o">=</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span>
<span class="p">{</span>
    <span class="c1">// 适配器容器 deque&lt;_Tp&gt;</span>
    <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>

      <span class="cm">/**
       *  Returns a read/write reference to the data at the first
       *  element of the %stack.
       */</span>
      <span class="n">reference</span>
      <span class="n">top</span><span class="p">()</span>
      <span class="p">{</span>
         <span class="n">__glibcxx_requires_nonempty</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="cm">/**
       *  @brief  Add data to the top of the %stack.
       *  @param  __x  Data to be added.
       *
       *  This is a typical %stack operation.  The function creates an
       *  element at the top of the %stack and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */</span>
      <span class="kt">void</span>
      <span class="nf">push</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
      <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__x</span><span class="p">));</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="72-queue">7.2. queue</h3> <p><code class="language-plaintext highlighter-rouge">std::queue</code> 类是容器适配器，它给予程序员队列的功能——尤其是 <code class="language-plaintext highlighter-rouge">FIFO</code> （先进先出）数据结构。</p> <p>适配器可以为标准容器 <code class="language-plaintext highlighter-rouge">std::deque</code> 和 <code class="language-plaintext highlighter-rouge">std::list</code>。</p> <p>实现方式一般是声明适配器变量，然后封装调用适配器容器函数来实现自己函数功能。例如 <code class="language-plaintext highlighter-rouge">push()</code> <code class="language-plaintext highlighter-rouge">pop()</code>函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Sequence</span> <span class="o">=</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">queue</span>
<span class="p">{</span>
    <span class="c1">// 适配器容器 deque&lt;_Tp&gt;</span>
    <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>

      <span class="cm">/**
       *  @brief  Add data to the end of the %queue.
       *  @param  __x  Data to be added.
       *
       *  This is a typical %queue operation.  The function creates an
       *  element at the end of the %queue and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */</span>
      <span class="kt">void</span>
      <span class="n">push</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
      <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__x</span><span class="p">));</span> <span class="p">}</span>

      <span class="cm">/**
       *  @brief  Removes first element.
       *
       *  This is a typical %queue operation.  It shrinks the %queue by one.
       *  The time complexity of the operation depends on the underlying
       *  sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */</span>
      <span class="kt">void</span>
      <span class="nf">pop</span><span class="p">()</span>
      <span class="p">{</span>
        <span class="n">__glibcxx_requires_nonempty</span><span class="p">();</span>
       <span class="n">c</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
      <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="73-priority_queue">7.3. priority_queue</h3> <p><code class="language-plaintext highlighter-rouge">priority_queue</code> 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与提取。</p> <p>适配器可以为标准容器 <code class="language-plaintext highlighter-rouge">std::vector</code>（包括 <code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;</code>）和 <code class="language-plaintext highlighter-rouge">std::deque</code>。</p> <p>实现方式一般是声明适配器变量，然后封装调用适配器容器函数来实现自己函数功能。例如 <code class="language-plaintext highlighter-rouge">top()</code> <code class="language-plaintext highlighter-rouge">pop()</code>函数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Sequence</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">&gt;,</span> <span class="k">typename</span> <span class="n">_Compare</span>  <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">priority_queue</span>
<span class="p">{</span>
    <span class="c1">// 适配器容器 vector&lt;_Tp&gt;</span>
    <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">_Compare</span>  <span class="n">comp</span><span class="p">;</span>

      <span class="cm">/**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %queue.
       */</span>
      <span class="n">const_reference</span>
      <span class="n">top</span><span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
       <span class="n">__glibcxx_requires_nonempty</span><span class="p">();</span>
       <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="cm">/**
       *  @brief  Removes first element.
       *
       *  This is a typical %queue operation.  It shrinks the %queue
       *  by one.  The time complexity of the operation depends on the
       *  underlying sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */</span>
      <span class="kt">void</span>
      <span class="nf">pop</span><span class="p">()</span>
      <span class="p">{</span>
        <span class="n">__glibcxx_requires_nonempty</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pop_heap</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
        <span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
      <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="8-rb_tree">8. rb_tree</h2> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/RB-tree.png" alt="RB-tree"></p> <p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p> <ol> <li>节点是红色或黑色。</li> <li>根是黑色。</li> <li>所有叶子都是黑色（叶子是NIL节点）。</li> <li>每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）</li> <li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li> </ol> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/rb_tree.drawio.svg" alt="RB-tree2"></p> <h3 id="81-set-multiset">8.1. set, multiset<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> </h3> <p><code class="language-plaintext highlighter-rouge">std::set</code> 是关联容器，含有 <code class="language-plaintext highlighter-rouge">Key</code> 类型对象的已排序集。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。<code class="language-plaintext highlighter-rouge">set</code> 通常以红黑树实现。</p> <p><code class="language-plaintext highlighter-rouge">std::multiset</code> 是含有 <code class="language-plaintext highlighter-rouge">Key</code> 类型对象有序集的容器。与 <code class="language-plaintext highlighter-rouge">set</code> 不同，它允许多个 <code class="language-plaintext highlighter-rouge">Key</code> 拥有等价的值。用关键比较函数 <code class="language-plaintext highlighter-rouge">Compare</code> 进行排序。搜索、插入和移除操作拥有对数复杂度。</p> <h3 id="82-map-multimap">8.2. map, multimap</h3> <p><code class="language-plaintext highlighter-rouge">std::map</code> 是有序键值对容器，它的元素的键是唯一的。用比较函数 <code class="language-plaintext highlighter-rouge">Compare</code> 排序键。搜索、移除和插入操作拥有对数复杂度。<code class="language-plaintext highlighter-rouge">map</code> 通常实现为红黑树。</p> <p><code class="language-plaintext highlighter-rouge">multimap</code> 是关联容器，含有键值对的已排序列表，同时容许多个元素拥有同一键。按照应用到键的比较函数 <code class="language-plaintext highlighter-rouge">Compare</code> 排序。搜索、插入和移除操作拥有对数复杂度。拥有等价键的键值对的顺序就是插入顺序，且不会更改。</p> <h2 id="9-hashtable">9. hashtable</h2> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/hashtable.png" alt="hashtable"></p> <p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p> <p><img src="/assets/images/cpp/2023-01-14-STL%E5%9B%BE%E8%A7%A3/hashtable.drawio.svg" alt="hashtable2"></p> <h3 id="91-unordered_set-unordered_multiset">9.1. unordered_set, unordered_multiset</h3> <p><code class="language-plaintext highlighter-rouge">unordered_set</code> 是含有 <code class="language-plaintext highlighter-rouge">Key</code> 类型唯一对象集合的关联容器。搜索、插入和移除拥有平均常数时间复杂度。在内部，元素并不以任何特别顺序排序，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。不可修改容器元素（即使通过非 const 迭代器），因为修改可能更改元素的哈希，并破坏容器。</p> <p><code class="language-plaintext highlighter-rouge">unordered_multiset</code> 是关联容器，含有可能非唯一 <code class="language-plaintext highlighter-rouge">Key</code> 类型对象的集合。搜索、插入和移除拥有平均常数时间复杂度。不要求此容器的迭代顺序稳定。</p> <h3 id="92-unordered_map-unordered_multimap">9.2. unordered_map, unordered_multimap</h3> <p><code class="language-plaintext highlighter-rouge">unordered_map</code> 是关联容器，含有带唯一键的键-值 <code class="language-plaintext highlighter-rouge">pair</code> 。搜索、插入和元素移除拥有平均常数时间复杂度。元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。</p> <p><code class="language-plaintext highlighter-rouge">unordered_multimap</code> 是无序关联容器，支持等价的键（一个 unordered_multimap 可含有每个键值的多个副本）和将键与另一类型的值关联。 <code class="language-plaintext highlighter-rouge">unordered_multimap</code> 类支持向前迭代器。搜索、插入和移除拥有平均常数时间复杂度。不要求此容器的迭代顺序稳定。</p> <h2 id="参考">参考</h2> <p>转载自 <a href="https://august295.github.io/posts/STL%E5%9B%BE%E8%A7%A3/" rel="external nofollow noopener" target="_blank">STL 图解</a></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p><a href="https://zhuanlan.zhihu.com/p/354191253" rel="external nofollow noopener" target="_blank">深入剖析STL内存分配器 allocator 及其萃取器</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2"> <p><a href="https://zhuanlan.zhihu.com/p/352606819" rel="external nofollow noopener" target="_blank">c++ STL迭代器（iterator)</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p><a href="https://zh.cppreference.com/w/cpp" rel="external nofollow noopener" target="_blank">C++ 参考手册</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/al-folio-local-deploy-ubuntu2404/">al-folio 本地部署记录（Ubuntu 24.04）</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/C++-Traits/">C++ Traits</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/">道格拉斯-普克算法(Douglas–Peucker algorithm)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/CMake%E6%94%AF%E6%8C%81%E5%BA%93/">CMake支持库收集</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/QGC%E9%A3%9E%E8%A1%8C%E5%89%8D%E6%A3%80%E6%9F%A5/">QGC代码架构解析：飞行前检查（起飞条件）</a> </li> </div> </div> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Roderick Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?v=c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>