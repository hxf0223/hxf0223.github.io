---
title: 整理：内存模型 (OnGoing)
date: 2024-08-11 +0800 # 2022-01-01 13:14:15 +0800 只写日期也行；不写秒也行；这样也行 2022-03-09T00:55:42+08:00
categories: [cpp]
tags: [cpp, cpu, linux]      # TAG names should always be lowercase

# 以下默认false
math: true
mermaid: true
# pin: true
---

## 1. CPU Cache 内部结构 ##

![CPU structure](/assets/images/cpu/memory_order_20240811/cpu_structure.png)

一个core内部结构：cache, store buffer, invalidate queue，结构如下图所示：

![CPU cache structure](/assets/images/cpu/memory_order_20240811/core_structure_cache_store_buffer_inv_queue.png)

### 1.1 为什么需要 MESI ###

`MESI`是`CPU`内部多个`core`同步通讯协议，保证多个`core`中的`cache`的数据一致性。

通过给`cache line`设置状态位，以及`CPU core`（也可能有内存控制器参与）之间的消息同步逻辑，让多个`core`中的`cache`数据保持一致性。`core`之间通讯过程示例：[知乎 --为什么需要内存屏障](https://zhuanlan.zhihu.com/p/55767485)。

在没有`store buffer`之前，`MESI`可以保证不需要`memory fence`指令也可以保证数据的一致性（理解：但不能保证指令重排导致两个线程访问先后顺序）。

## 2. memory fence ##

### 2.1 概念及理论 ###

- 同步点：针对同一个`原子变量`的`load`操作与`store`操作，分别构成一个`同步点`。其概念有三要素：(1)：`load`/`store`操作，(2)：针对同一个原子变量，(3)：以及在不同线程中；
- `synchronize-with` 关系，该概念包含两个含义：(1)：同一个同步点，(2)：读取的值是另一个同步点写入的值；
- `happens-before` 关系；

### 2.2 为什么需要 memroy fence ###

例如有两个`CPU core`：`CPU0`，以及`CPU1`，`CPU0`写入，`CPU1`读取同一个变量。`CPU0`认为写入到`store buffer`就够了，而`CPU1`则认为必须写入到`cache`才叫写入。

所以，在`MESI`协议的基础上，再添加一个`memory fence`，以保证`CPU0`与`CPU1`的`cache`数据一致性。

详细知识参考：

- [说透缓存一致性与内存屏障](https://www.cnblogs.com/chanmufeng/p/16523365.html)
- [CPU 缓存一致性与内存屏障](https://wingsxdu.com/posts/note/cpu-cache-and-memory-barriers/)
- [Cache一致性和内存一致性](https://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/)
- [Acquire and Release Fences](https://preshing.com/20130922/acquire-and-release-fences/)

## 3. memory order seq_cst 与 release_acquire 区别 ##

TODO

## 更多资料 ##

- [C++ Concurrency In Action 2ed 中文翻译](https://simonhancrew.github.io/CppConcurencyInAction/)
- [C++ Concurrency in Action, 2nd Edition](/assets/pdf/cpu/C++%20Concurrency%20in%20Action,%202nd%20Edition.pdf)

## HTTP 参考资料 ##

- memory ordering: http://gavinchou.github.io/summary/c++/memory-ordering
